<html>
<head>
<script type="text/javascript" src='google-code-prettify/prettify.js'></script>
<link type='text/css' rel="Stylesheet" href='google-code-prettify/prettify.css' />
</head>
<body onload='prettyPrint()'>
<h1>Recipes o'mercy</h1>

<h2>Embed zigfu browser plugin object</h2>

<pre class="prettyprint"><code class="language-js">zig.embed();
</code></pre>


<h2>Read sensor state</h2>

<pre class="prettyprint"><code class="language-js">zig.TODO();
</code></pre>

<h2>Handling ZDK events in JavaScript</h2>

Most objects in the ZDK expose events. There are 2 ways to consume events triggered by ZDK: specific event handlers, and event listener objects. A specific event handler will get called for a specific event triggered by a specific object, similar to the DOM events we are all familiar with. The event listener object will receive callbacks for <em>all</em> of the events triggered by our target object.

<pre class="prettyprint"><code class="language-js">// Method 1: specific event listeners
o.addEventListener('eventname1', callback);
o.removeEventListener('eventname1', callback);

// also works with anonymous callbacks
var cb = object.addEventListener('eventname2', function() { /* do something */ });
o.removeEventListener('eventname2', cb);

// Method 2: listener object
// Note that onattach and ondetach are only called when using addListener, and not addEventListener
var listener = {
	oneventname1 : callback1,
	oneventname2 : callback2,
	onattach : callback3,
	ondetach : callback4,
}
o.addListener(listener);
o.removeListener(listener);

</code></pre>

<h2>User found & lost notifications</h2>

The main zig object exposes 2 events that allow us to keep track of all tracked users in the sensor field of view. Below are two ways to get notifications when the userfound and userlost events occur.

<pre class="prettyprint"><code class="language-js">// Method 1: specific event listeners
zig.addEventListener('userfound', function(user) {
	console.log('Found user. ID: ' + user.id);
});
zig.addEventListener('userlost', function(user) {
	console.log('Lost user. ID: ' + user.id);
});

// Method 2: listener object
zig.addListener({
	onuserfound: function(user){
		console.log('Found user. ID: ' + user.id);
	},
	onuserlost: function(user){
		console.log('Lost user. ID: ' + user.id);
	}
});
</code></pre>


<h2>Wait for first user with full body skeleton data</h2>

The EngageUsersWithSkeleton helps us distinguish between the tracked users, and the specific tracked users that are "in control". A user controlling a game or a UI is "engaged". There are many different ways to choose the engaged user (or users) - below are a few simple use cases.

<pre class="prettyprint"><code class="language-js">var engager = zig.EngageUsersWithSkeleton(1);
engager.addEventListener('userengaged', function(user) {
	console.log('User engaged: ' + user.id);
});
engager.addEventListener('userdisengaged', function(user) {
	console.log('User disengaged: ' + user.id);
});
</code></pre>


<h2>Wait for multiple users with full body skeleton data</h2>

Multiple users (2 in this case). Great for split screen gaming!

<pre class="prettyprint"><code class="language-js">var multiEngager = zig.EngageUsersWithSkeleton(2);
multiEngager.addEventListener('userengaged', function(user) {
	console.log('User engaged: ' + user.id);
});
multiEngager.addEventListener('userdisengaged', function(user) {
	console.log('User disengaged: ' + user.id);
});
multiEngager.addEventListener('allusersengaged', function(users) {
	console.log('Engaged all users, starting game');
	// start game
});
</code></pre>


<h2>Single user UI session</h2>

A common ZDK use case is a UI that can be controlled by one user at a time. The singleUserSession object (this is actually an instance of HandSessionDetector) notifies us when a tracked user is trying to control the UI, and ensures that only one user can be in control at a time.

Note that this is great for a "Pure UI" application. If the UI being controlled is a game menu system, it might be better to choose the engaged user in a different way (EngageUsersWithSkeleton, for instance) and then add a HandSessionDetector to the engaged user. This will ensure that only the user that is actually playing the game can control the game menus. (See seperate recipe)

<pre class="prettyprint"><code class="language-js">zig.singleUserSession.addEventListener('userengaged', function(user) {
	console.log('User started UI session: ' + user.id);
});
zig.singleUserSession.addEventListener('userdisengaged', function(user) {
	console.log('User ended UI session: ' + user.id);
});
zig.singleUserSession.addEventListener('sessionstart', function(initialPosition) {
	console.log('Session started at ' + initialPosition);
});
zig.singleUserSession.addEventListener('sessionend', function() {
	console.log('Session ended')
});
</code></pre>


<h2>Game menu, controllable only by engaged user</h2>

<pre class="prettyprint"><code class="language-js">// game menu. just a simple cursor for now
var cursor = zig.controls.Cursor();
var gameMenu = {
	onsessionstart : function(fp) { /* visualize session starting in game menu */ },
	onsessionupdate : function(p) { /* visualize session ending in game menu */},
	onattach : function(user) { user.addListener(cursor); }
};

var engager = zig.EngageUsersWithSkeleton(1);
engager.addEventListener('userengaged', function(user) {
	console.log('User engaged: ' + user.id);
	// create our hand session detector, add the game menu to it
	var hsd = zig.HandSessionDetector();
	hsd.addListener(gameMenu)
	// add the session detector to the engaged user - only this user can
	// control the gameMenu
	user.addListener(hsd);
});
engager.addEventListener('userdisengaged', function(user) {
	console.log('User disengaged: ' + user.id);
});
</code></pre>


<h2>Print head position every frame for first engaged user</h2>

Skeleton data can be accessed via user.skeleton. Note that the skeleton data will be valid only if user.skeletonTracked is true (this will always be the case for user engaged by EngageUsersWithSkeleton). zig.Joints contains a full list of possible joints, but not all of them will always be available. This depends on the underlying middleware used by the ZDK.

<pre class="prettyprint"><code class="language-js">var engager = zig.EngageUsersWithSkeleton(1);
engager.addEventListener('userengaged', function(user) {
	console.log('User engaged: ' + user.id);

	user.addEventListener('userupdate', function(user) {
		console.log('Head position: ' + user.skeleton[zig.Joints.Head].position);
	});
});
engager.addEventListener('userdisengaged', function(user) {
	console.log('User disengaged: ' + user.id);
});
zig.addListener(engager);
</code></pre>


<h2>Horizontal Fader with range of 0 - 100</h2>

<pre class="prettyprint"><code class="language-js">var f = zig.controls.Fader(zig.Orientation.X);
f.addEventListener('valuechange', function (f) {
	console.log('Fader value: ' + (f.value * 100));
})
zig.singleUserSession.addListener(f);
</code></pre>


<h2>Vertical Fader with 4 items</h2>

<pre class="prettyprint"><code class="language-js">var f = zig.controls.Fader(zig.Orientation.Y);
f.itemsCount = 4;
f.addEventListener('hoverstart', function (f) {
	console.log('Fader item hover: ' + f.hoverItem);
});
f.addEventListener('hoverstop', function(f) {
	console.log('Fader item not hovering any more: ' + f.hoverItem);
})
zig.singleUserSession.addListener(f);
</code></pre>

<h2>Push detector events</h2>

<pre class="prettyprint"><code class="language-js">// PushDetector
var pushDetector = zig.controls.PushDetector();
pushDetector.addEventListener('push', function(pd) {
	console.log('PushDetector: Push');
});
pushDetector.addEventListener('release', function(pd) {
	console.log('PushDetector: Release');
});
pushDetector.addEventListener('click', function(pd) {
	console.log('PushDetector: Click');
});
</code></pre>

<h2>Swipe detector events</h2>

<pre class="prettyprint"><code class="language-js">// SwipeDetector
var swipeDetector = zig.controls.SwipeDetector();
swipeDetector.addEventListener('swipeup', function(pd) {
	console.log('SwipeDetector: Swipe Up');
});
swipeDetector.addEventListener('swipedown', function(pd) {
	console.log('SwipeDetector: Swipe Down');
});
swipeDetector.addEventListener('swipeleft', function(pd) {
	console.log('SwipeDetector: Swipe Left');
});
swipeDetector.addEventListener('swiperight', function(pd) {
	console.log('SwipeDetector: Swipe Right');
});
swipeDetector.addEventListener('swipe', function(dir) {
	console.log('SwipeDetector: Swipe direction: ' + dir);
});
</code></pre>

<h2>Wave detector events</h2>

<pre class="prettyprint"><code class="language-js">// WaveDetector
var waveDetector = zig.controls.WaveDetector();
waveDetector.addEventListener('wave', function(pd) {
	console.log('WaveDetector: Wave');
});
</code></pre>

<h2>Steady detector events</h2>

<pre class="prettyprint"><code class="language-js">// SteadyDetector
var steadyDetector = zig.controls.SteadyDetector();
steadyDetector.addEventListener('steady', function(sd) {
	console.log('SteadyDetector: Steady');
});
steadyDetector.addEventListener('unsteady', function(sd) {
	console.log('SteadyDetector: Unsteady');
});
</code></pre>

<h2>Simple cursor</h2>

This snippet shows how to control a cursor element based on the ZDK Cursor control:
<ol>
<li>Showing and hiding the cursor element when a hand session starts and ends.</li>
<li>Moving the cursor element when we should</li>
<li>Adding a 'pushed' class the the cursor when appropiate</li>
</ol>

<pre class="prettyprint"><code class="language-js">// Create cursor and cursor dom element
var c = zig.controls.Cursor();
var ce = document.createElement('div');
ce.id = 'mycursor';
document.body.appendChild(ce);

// show/hide cursor on session start/end
zig.singleUserSession.addEventListener('sessionstart', function(focusPosition) {
	ce.style.display = 'block';
});
zig.singleUserSession.addEventListener('sessionend', function() {
	ce.style.display = 'none';
});

// move the cursor element on cursor move
c.addEventListener('move', function(cursor) {
	ce.style.left = (c.x * window.innerWidth - (ce.offsetWidth / 2)) + "px";
	ce.style.top = (c.y * window.innerHeight - (ce.offsetHeight / 2)) + "px";
});

// Add/remove 'pushed' class on cursor push/release
c.addEventListener('push', function(c) {
	ce.classList.add('pushed');
});
c.addEventListener('release', function(c) {
	ce.classList.remove('pushed');
});

// Simulate mouse click on our virtual cursor
c.addEventListener('click', function(c) {
	var xpos = c.x * window.innerWidth;
	var ypos = c.y * window.innerHeight;
	var evt = document.createEvent("MouseEvents");
	evt.initMouseEvent("click", true, true, window, 1, xpos, ypos, xpos, ypos, false, false, false, false, 0, null);
	elt.dispatchEvent(evt);
});

// Add cursor to our single user UI session
zig.singleUserSession.addListener(c);
</code></pre>

<h2>Top-down "users radar"</h2>

<pre class="prettyprint"><code class="language-js">function usersRadar(parentElement) {
	// physical dimensions of radar in room. Lets use 4m x 4m
	this.radarWidth = 4000;
	this.radarHeight = 4000;

	this.onuserfound = function(user) {
		// create a new element for this user, add to dom
		var el = document.createElement('div');
		el.classList.add('user');
		parentElement.appendChild(el);

		// move the element every frame
		user.addEventListener('userupdate', function(user) {
			// we need to convert [user.x, user.z] to [screen.x, screen.y]
			// first get normalized user position
			var xpos = (user.position[0] / this.radarWidth) + 0.5; // 0 for x is actually the center of the depthmap
			var ypos = (user.position[2] / this.radarHeight);
			// convert normalized position to fit into our radar element
			el.style.left = xpos * parentElement.offsetWidth - (el.offsetWidth / 2) + "px";
			el.style.top = ypos * parentElement.offsetHeight - (el.offsetHeight / 2) + "px";
		});
	}
	
	this.onuserlost = function(user) {
		// remove the element we created from the dom and ZDK user object
		parentElement.removeChild(user.radarElement);
		delete user.radarElement;
	}
}

// make sure you add &lt;div id='radar'&gt;&lt;/div&gt; to your html body
var radar = new usersRadar(document.getElementById('radar'));
zig.addListener(radar);
</code></pre>

</body>
</html>

