// these will only be valid after ctor is called
var io; 
var synclist;

var rooms = {}
var roomslist;

var lastRoomId = 1337;
var lastUserId = 1337;

function startRoom(data) {
	// room id stuff
	if (undefined === data.roomid) {
		// TODO: allocate an actual roomid
		data.roomid = lastRoomId;
		lastRoomId++;
	}
	var roomid = data.roomid;

	if (undefined === data.roomname) {
		data.roomname = "[Unnamed room]";
	}

	// if room doesn't exist, create it
	if (!rooms.hasOwnProperty(roomid)) {
		rooms[roomid] = {
			// shared room data
			roomdata : synclist.create(roomid + ":roomdata"),

			// private room data
			location : data.location,
			pin : data.pin,
			adminpin : data.adminpin,

			// room connected user list
			users : {},
			userslist : synclist.create(roomid + ":userslist"),

			// locks for this room
			locks : {},
		};

		rooms[roomid].roomdata.add(data.roomname, "roomname");

		// maintain our rooms synclist (TODO : to be replaced later of course)
		roomslist.add({roomname : data.roomname}, roomid);
	}

	return roomid;
}

function joinRoom(socket, roomid, data) {
	// associate with roomid
	socket.roomid = roomid;
	socket.join(socket.roomid);

	// allocate user id
	socket.userid = lastUserId;
	lastUserId++;

	// user name
	var username = (undefined !== data.username) ? data.username : "[Guest]";

	// add to user list
	var joining = rooms[roomid];
	joining.userslist.add(username, socket.userid);
	joining.users[socket.userid] = {
		username : username,
		location : data.location,
	};

	// send the TV a msg indicating someone connected
	socket.broadcast.to(socket.roomid + "_host").emit("zigmote-userJoined", { userid : socket.userid, username : username });

	// TODO: maybe update host location if controller has one and tv doesn't
}

function leaveRoom(socket) {
	if (undefined !== socket.roomid) {
		rooms[socket.roomid].userslist.remove(socket.userid);
		delete rooms[socket.roomid].users[socket.userid];
		unlockAll(socket);
	}
}

function doLock(socket, lockid) {
	// this lock is held
	if (rooms[socket.roomid].locks.hasOwnProperty(lockid)) {
		// by the same client
		if (rooms[socket.roomid].locks[lockid] == socket.id) {
			// umm.. ok?
			socket.emit("zigmote-lock", { success : true });
			return;
		}
		// for now just fail. 
		// TODO: maybe add to queue? maybe notify client when lock is released?
		socket.emit("zigmote-lock", { success : false });
	} else {
		// hold the lock		
		rooms[socket.roomid].locks[lockid] = socket.id;
		// let the requester know
		socket.emit("zigmote-lock", { success : true });
		// let everyone know
		io.sockets.in(socket.roomid).emit("zigmote-locked", { lockid : lockid, userid : socket.userid });
		// store this in case we get disconnected
		if (undefined === socket.locks) {
			socket.locks = [];
		}
		socket.locks.push(lockid);
	}
}

function doUnlock(socket, lockid) {
	// if this lock isn't held
	if (!rooms[socket.roomid].locks.hasOwnProperty(lockid)) {
		return;
	}

	// if this lock not held by the unlocker
	if (!rooms[socket.roomid].locks[lockid] == socket.id) {
		return;
	}

	// release the lock
	delete rooms[socket.roomid].locks[lockid];
	socket.locks.splice(socket.locks.indexOf(lockid), 1);

	// notify everyone
	io.sockets.in(socket.roomid).emit("zigmote-unlocked", { lockid : lockid });
}

function unlockAll(socket) {
	// no locks? quick out
	if (undefined === socket.locks) {
		return;
	}

	var lock;
	while (socket.locks.length) {
		doUnlock(socket, socket.locks[0]);
	}
}

function zigmotify(socket) {

	if (undefined !== socket.zigmotified) {
		// already zigmotified
		return;
	}
 	socket.zigmotified = true;

	//-------------------------------------------------------------------------
	// Messages from the host
	//-------------------------------------------------------------------------

	socket.on('zigmote-startRoom', function(data) {
		var roomid = startRoom(data);

		socket.roomid = roomid;
		socket.join(roomid);
		socket.join(roomid + "_host");

		socket.emit('zigmote-roomStarted', {
			roomid : roomid,
			roomsharedid : rooms[roomid].roomdata.id,
			userslistid : rooms[roomid].userslist.id,
		});

		socket.on('zigmote-rename', function(data) {
			rooms[socket.roomid].roomdata.set("roomname", data.roomname);
			roomslist.set(data.roomid, data.roomname);
		});

		socket.on('zigmote-lock', function(data) {
			doLock(socket, data.lockid);
		});

		socket.on('zigmote-unlock', function(data) {
			doUnlock(socket, data.lockid);
		});

		// when the host disconnects
		socket.on('disconnect', function () {
			// TODO: persistence between pages, but for now assume actual disconnection
			delete rooms[socket.roomid];
			roomslist.remove(socket.roomid);

			// let clients know
			socket.broadcast.to(socket.roomid).emit('zigmote-hostGone');
		});
	});


	//-------------------------------------------------------------------------
	// Messages from controllers
	//-------------------------------------------------------------------------

	socket.on('zigmote-getRoomList', function(data) {
		// LATERZ, by location. synclist for now
	});

	socket.on('zigmote-joinRoom', function(data) {
		// check if room exists
		if (false) {
			socket.emit('zigmote-joinedRoom', { success : false, errormsg : "Invalid room id"});
			return;
		}

		// check permissions
		if (31337 == data.roomid) {
			socket.emit('zigmote-joinedRoom', { success : false, errormsg : "No permission to join"});	
			return;
		}

		// are we already in a room?
		if (undefined !== socket.roomid) {
			// is it this one?
			if (socket.roomid == data.roomid) {
				// umm... cool?
				socket.emit('zigmote-joinedRoom', { success : true });
				return;
			}

			// unjoin current room
			leaveRoom(socket);
		}

		// join
		joinRoom(socket, data.roomid, data);

		socket.on("zigmote-rename", function(data) {
			rooms[socket.roomid].userslist.set(socket.userid, data.username);
			rooms[socket.roomid].users[socket.userid].username = data.username;
		});

		socket.on("zigmote-sendToHost", function(data) {
			console.log("Controller send to host " + data.command);
			io.sockets.in(socket.roomid + "_host").emit("zigmote-sendToHost", data);
		});

		// lock/unlock
		socket.on('zigmote-lock', function(data) {
			doLock(socket, data.lockid);
		});

		socket.on('zigmote-unlock', function(data) {
			doUnlock(socket, data.lockid);
		});


		// register the disconnect to notify when user leaves
		socket.on('disconnect', function() {
			leaveRoom(socket);
		});

		socket.emit('zigmote-joinedRoom', { 
			success : true,
			roomsharedid : rooms[socket.roomid].roomdata.id,
		});	
	});
}

// ctor, init with socket.io
function listen(socketio) {
	io = socketio;
	synclist = require('synclist').listen(io);

	io.sockets.on('connection', function (socket) {
		zigmotify(socket);
	});

	roomslist = synclist.create("roomslist");
	roomslist.add({ roomname : "Restricted room" }, 31337);

	// public api for server side
	return {}
};

exports.listen = listen;
