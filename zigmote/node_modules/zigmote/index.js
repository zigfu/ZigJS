// these will only be valid after ctor is called
var io; 
var synclist;

var rooms = {}
var roomslist;

var lastUserId = 1337;

// randomString returns a pseude-random ASCII string which contains at least the specified number of bits of entropy
// the return value is a string of length ⌈bits/6⌉ of characters from the base64 alphabet
function randomString(bits){
	var chars,rand,i,ret
		chars='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
		ret=''
		// in v8, Math.random() yields 32 pseudo-random bits (in spidermonkey it gives 53)
		while(bits > 0){
		rand=Math.floor(Math.random()*0x100000000) // 32-bit integer
		// base 64 means 6 bits per character, so we use the top 30 bits from rand to give 30/6=5 characters.
		for(i=26; i>0 && bits>0; i-=6, bits-=6) ret+=chars[0x3F & rand >>> i]
	}
	return ret
}


function startRoom(socket, data) {
	// room id stuff
	if (undefined === data.roomid || !rooms.hasOwnProperty(data.roomid)) {
		data.roomid = randomString(48);
	}
	var roomid = data.roomid;

	if (undefined === data.roomname) {
		data.roomname = "[Unnamed room]";
	}

	if (undefined === data.roomtype) {
		data.roomtype = "notype";
	}

	socket.roomtype = data.roomtype;

	// if this room already exists
	if (rooms.hasOwnProperty(roomid)) {
		// remove the cleanup timer for it
		if (undefined !== rooms[roomid].cleanupTimer) {
			clearTimeout(rooms[roomid].cleanupTimer);
			delete rooms[roomid].cleanupTimer;
		}
		
		// notify the host of any existing locks in this room
		if (rooms[roomid].locks !== undefined) {
			var locks = rooms[roomid].locks;
			for (var l in locks) if (locks.hasOwnProperty(l)) {
				var userid = io.sockets.socket(locks[l]).userid || 0;
				socket.emit('zigmote-locked', { lockid : l, userid : userid })
			}
		}
	}

	// if room doesn't exist, create it
	if (!rooms.hasOwnProperty(roomid)) {
		rooms[roomid] = {
			// shared room data
			roomdata : synclist.create(roomid + ":roomdata"),

			// private room data
			location : data.location,
			pin : data.pin,
			adminpin : data.adminpin,

			// room connected user list
			users : {},
			userslist : synclist.create(roomid + ":userslist"),

			// locks for this room
			locks : {},
		};

		rooms[roomid].roomdata.add(data.roomname, "roomname");

		// maintain our rooms synclist (TODO : to be replaced later of course)
		//roomslist.add({roomname : data.roomname}, roomid);
		synclist.create("roomslist:"+data.roomtype).add({roomname : data.roomname}, roomid);
	}

	return roomid;
}

function joinRoom(socket, roomid, data) {
	// associate with roomid
	socket.roomid = roomid;
	socket.join(socket.roomid);

	// allocate user id
	socket.userid = lastUserId;
	lastUserId++;

	// user name
	var username = (undefined !== data.username) ? data.username : "[Guest]";

	// add to user list
	var joining = rooms[roomid];
	joining.userslist.add(username, socket.userid);
	joining.users[socket.userid] = {
		username : username,
		location : data.location,
	};

	// send the TV a msg indicating someone connected
	socket.broadcast.to(socket.roomid + "_host").emit("zigmote-userJoined", { userid : socket.userid, username : username });

	// TODO: maybe update host location if controller has one and tv doesn't
}

function leaveRoom(socket) {
	if (undefined !== socket.roomid) {
		if (rooms.hasOwnProperty(socket.roomid)) {
			rooms[socket.roomid].userslist.remove(socket.userid);
			delete rooms[socket.roomid].users[socket.userid];
			unlockAll(socket);
		}
		delete socket.roomid;
	}
}

function doLock(socket, lockid) {
	// this lock is held
	if (rooms[socket.roomid].locks.hasOwnProperty(lockid)) {
		// by the same client
		if (rooms[socket.roomid].locks[lockid] == socket.id) {
			// umm.. ok?
			socket.emit("zigmote-lock", { success : true, lockid : lockid });
			return;
		}
		// for now just fail. 
		// TODO: maybe add to queue? maybe notify client when lock is released?
		socket.emit("zigmote-lock", { success : false, lockid : lockid });
	} else {
		// hold the lock		
		rooms[socket.roomid].locks[lockid] = socket.id;
		// let the requester know
		socket.emit("zigmote-lock", { success : true, lockid : lockid });
		// let everyone know
		io.sockets.in(socket.roomid).emit("zigmote-locked", { lockid : lockid, userid : socket.userid });
		// store this in case we get disconnected
		if (undefined === socket.locks) {
			socket.locks = [];
		}
		socket.locks.push(lockid);
	}
}

function doUnlock(socket, lockid) {
	// if this lock isn't held
	if (!rooms[socket.roomid].locks.hasOwnProperty(lockid)) {
		return;
	}

	// if this lock not held by the unlocker
	if (!rooms[socket.roomid].locks[lockid] == socket.id) {
		return;
	}

	// release the lock
	delete rooms[socket.roomid].locks[lockid];
	socket.locks.splice(socket.locks.indexOf(lockid), 1);

	// notify everyone
	io.sockets.in(socket.roomid).emit("zigmote-unlocked", { lockid : lockid });
}

function unlockAll(socket) {
	// no locks? quick out
	if (undefined === socket.locks) {
		return;
	}

	var lock;
	while (socket.locks.length) {
		doUnlock(socket, socket.locks[0]);
	}
}

function zigmotify(socket) {

	if (undefined !== socket.zigmotified) {
		// already zigmotified
		return;
	}
 	socket.zigmotified = true;

	//-------------------------------------------------------------------------
	// Messages from the host
	//-------------------------------------------------------------------------

	socket.on('zigmote-startRoom', function(data) {
		var roomid = startRoom(socket, data);

		socket.roomid = roomid;
		socket.join(roomid);
		socket.join(roomid + "_host");

		socket.emit('zigmote-roomStarted', {
			roomid : roomid,
			roomsharedid : rooms[roomid].roomdata.id,
			userslistid : rooms[roomid].userslist.id,
		});

		socket.on('zigmote-rename', function(data) {
			rooms[socket.roomid].roomdata.set("roomname", data.roomname);
			roomslist.set(data.roomid, data.roomname);
		});

		socket.on('zigmote-lock', function(data) {
			doLock(socket, data.lockid);
		});

		socket.on('zigmote-unlock', function(data) {
			doUnlock(socket, data.lockid);
		});

		// when the host disconnects
		socket.on('disconnect', function () {
			// if host disconnects, we start a timer before we
			// actually end the session
			rooms[roomid].cleanupTimer = setTimeout((function(rid){ return function(){
				// cleanup actual room data
				if (rooms.hasOwnProperty(rid)) {
					rooms[rid].userslist.clear();
					rooms[rid].roomdata.clear();
					delete rooms[rid];
				}

				// remove from type				
				synclist.create("roomslist:"+socket.roomtype).remove(rid);

				// let clients know
				socket.broadcast.to(rid).emit('zigmote-hostGone');
			}})(roomid), 1000 * 60);
		});
	});


	//-------------------------------------------------------------------------
	// Messages from controllers
	//-------------------------------------------------------------------------

	socket.on('zigmote-getRoomList', function(data) {
		// LATERZ, by location. synclist for now
	});

	socket.on('zigmote-joinRoom', function(data) {
		// check if room exists
		if (false) {
			socket.emit('zigmote-joinedRoom', { success : false, errormsg : "Invalid room id"});
			return;
		}

		// check permissions
		if (31337 == data.roomid) {
			socket.emit('zigmote-joinedRoom', { success : false, errormsg : "No permission to join"});	
			return;
		}

		// are we already in a room?
		if (undefined !== socket.roomid) {
			// is it this one?
			if (socket.roomid == data.roomid) {
				// umm... cool?
				socket.emit('zigmote-joinedRoom', { success : true });
				return;
			}

			// unjoin current room
			leaveRoom(socket);
		}

		// join
		joinRoom(socket, data.roomid, data);

		socket.on("zigmote-rename", function(data) {
			rooms[socket.roomid].userslist.set(socket.userid, data.username);
			rooms[socket.roomid].users[socket.userid].username = data.username;
		});

		socket.on("zigmote-sendToHost", function(data) {
			data.userid = socket.userid;
			io.sockets.in(socket.roomid + "_host").emit("zigmote-sendToHost", data);
		});

		// lock/unlock
		socket.on('zigmote-lock', function(data) {
			doLock(socket, data.lockid);
		});

		socket.on('zigmote-unlock', function(data) {
			doUnlock(socket, data.lockid);
		});


		// register the disconnect to notify when user leaves
		socket.on('disconnect', function() {
			leaveRoom(socket);
		});

		socket.emit('zigmote-joinedRoom', { 
			success : true,
			roomsharedid : rooms[socket.roomid].roomdata.id,
		});	
	});
}

// ctor, init with socket.io
function listen(socketio) {
	io = socketio;
	synclist = require('synclist').listen(io);

	io.sockets.on('connection', function (socket) {
		zigmotify(socket);
	});

	roomslist = synclist.create("roomslist");
	roomslist.add({ roomname : "Restricted room" }, 31337);

	// public api for server side
	return {}
};

exports.listen = listen;
